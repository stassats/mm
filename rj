#!/usr/bin/gosh
;;; -*- Mode: Scheme -*-

;;; This software is in the public domain and is
;;; provided with absolutely no warranty.

(use gauche.parseopt)
(use file.util)
(use srfi-13)

(define *what* #f)
(define *with* "")
(define *reverse* #f)
(define *test* #f)
(define *start* #f)
(define *amount* -1)
(define *depth* #f)

(define (main args)
  (let ((args (options (cdr args))))
    (walk-directories
     (lambda (old)
       (let ((new (process-file old)))
         (unless (equal? old new)
           (if *test*
               (display (format "Old: ~A, new: ~A.~%" old new))
               (move-file old new)))))
     args
     *depth*)))

(define (process-file file)
  (define name (string-downcase (path-sans-extension (sys-basename file))))
  (define path (sys-dirname file))
  (define extension (path-extension file))
  (define (replace what with)
    (set! name (regexp-replace-all what name with)))

  (for-each (lambda (x) (replace (car x) (cadr x)))
            '(("[\\]()`Â´':;,!|?=\"~*\\[]" "")
              (" " "_")
              ("\\.*[-_ ]\\.*" "_")
              ("&+" "_and_")
              ("@" "_at_")
              ("#" "_n")
              ("_+" "_")
              ("_$" "")
              ("^_" "")))
  (when *what*
    (replace *what* *with*))
  (when *reverse*
    (replace "^(\\d{4})_(.+)" "\\2_\\1"))

  (when *start*
    (let ((new (change-number name *start* *amount*)))
      (when new (set! name new))))

  (path-swap-extension (build-path path name) extension))

(define (change-number string start amount)
  "Change number from <start> by <amount>: 10_file -> 11_file"
  (rxmatch-let (rxmatch #/^(\d+)(\D.+)$/ string)
               (#f snum rest)
    (if snum
        (let ((num (string->number snum)))
          (if (>= num start)
              (let* ((str (number->string (+ amount num)))
                     (dif (- (string-length snum) ;; Count of padded zeros
                             (string-length str))))
                (string-append
                 (make-string (max dif 0) #\0)
                 str rest))
              #f))
        #f)))

(define (walk-directories proc files depth)
  (when (or (not depth) (>= depth 0))
    (for-each
     (lambda (x)
       (when (file-is-directory? x)
         (current-directory x)
         (walk-directories proc
                           (directory-list (current-directory) :children? #t)
                           (and depth (- depth 1)))
         (current-directory ".."))
       (proc x))
     files)))

(define (help)
  (print "delete=s with=s reverse start=n amount=n max-depth=n test")
  (exit))

(define (options args)
  (let-args args
     ((#f "d|delete=s"    => (cut set! *what* <>))
      (#f "w|with=s"      => (cut set! *with* <>))
      (#f "r|reverse"     => (cut set! *reverse* #t))
      (#f "s|start=n"     => (cut set! *start* <>))
      (#f "a|amount=n" -1 => (cut set! *amount* <>))
      (#f "m|max-depth=n" => (cut set! *depth* <>))
      (#f "t|test"        => (cut set! *test* #t))
      (#f "h|help"        => help)
      . rest)
    (if (pair? rest)
        (map simplify-path rest)
        (directory-list (current-directory) :children? #t))))
