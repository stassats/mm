#!/usr/bin/mzscheme -qC
;; -*- Mode: Scheme -*-

;; This software is in the public domain and is
;; provided with absolutely no warranty.

;;; BUG 04_would_you_....mp3 -> 04_would_you_mp3

(require (lib "cmdline.ss")
         (lib "file.ss")
         (lib "pregexp.ss"))

(define *what* #f)
(define *with* "")
(define *reverse* #f)
(define *test* #f)
(define *start* #f)
(define *amount* -1)
(define *depth* #f)

(define (main args)
  (let ((args (parse-options (cdr args))))
    (walk-directories
     (lambda (old)
       (let ((new (process-file old)))
         (unless (equal? old new)
           (if *test*
               (display (format "Old: ~A, new: ~A.~%" old new))
               (rename-file-or-directory old new)))))
     args
     *depth*)))

(define (process-file file)
  (define-values (path name _) (split-path file))
  (define (replace what with)
    (set! name (pregexp-replace* what name with)))
  (set! name (string-downcase (path->string name)))

  (for-each (lambda (x) (replace (car x) (cadr x)))
            '(("[]()`Â´':;,!|?=\"~*[]" "")
              (" " "_")
              ("[ \\-_]+(\\.[^\\.]+)$" "\\1")
              ("\\.*[-_ ]\\.*" "_")
              ("&+" "_and_")
              ("@" "_at_")
              ("#" "_n")
              ("_+" "_")
              ("\\.+" ".")
              ("\\.(?=.+\\.)" "_")))
  (when *what*
    (replace *what* *with*))
  (when *reverse*
    (replace "^(\\d{4})_(.+)" "\\2_\\1"))

  (when *start*
    (let ((new (change-number name *start* *amount*)))
      (when new (set! name new))))

  (if (path? path)
      (build-path path name)
      (build-path name)))

(define (change-number string start amount)
  "Change number from <start> by <amount>: 10_file -> 11_file"
  (let ((match (pregexp-match "^(\\d+)(\\D.+)$" string)))
    (if match
        (let* ((snum (cadr match))
               (num (string->number snum)))
          (if (>= num start)
              (let* ((str (number->string (+ amount num)))
                     (dif (- (string-length snum) ;; Count of padded zeros
                             (string-length str))))
                (string-append
                 (make-string (max dif 0) #\0)
                 str (caddr match)))
              #f))
        #f)))

(define (walk-directories proc files depth)
  (when (or (not depth) (>= depth 0))
    (for-each
     (lambda (x)
       (when (directory-exists? x)
         (current-directory x)
         (walk-directories proc (directory-list)
                           (and depth (- depth 1)))
         (current-directory ".."))
       (proc x))
     files)))

(define (parse-options arg)
  (command-line "rj" arg
                (once-each
                 [("-d" "--delete") what
                  "Delete regexp <what> or replcace with <with>"
                  (set! *what* what)]
                 [("-w" "--with") with
                  "Replace <what> with <with>"
                  (set! *with* with)]
                 [("-r" "--reverse")
                  "Reverse year: 1989_dir -> dir_1989"
                  (set! *reverse* #t)]
                 [("-t" "--test")
                  "Do not rename and print new names."
                  (set! *test* #t)]
                 [("-s" "--start") start
                  "Shift number in filename from <start> by <amount>: 05_file -> 04_file"
                  (set! *start* (string->number start))]
                 [("-a" "--amount") amount
                  "Default -1"
                  (set! *amount* (string->number amount))]
                 [("-m" "--max-depth") depth
                  "Maximum level of recursive directory walking."
                  (set! *depth* (string->number depth))])

                (args dir
                      (if (pair? dir)
                          (map simplify-path dir)
                          (directory-list)))))
